\input texinfo
@c -*-texinfo-*-

@c %**start of header
@setfilename guile-config.info
@documentencoding UTF-8
@settitle Guile Config Reference Manual
@c %**end of header

@include version.texi

@copying
Copyright @copyright{} 2015-2018 Alex Sassmannshausen

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end copying

@dircategory The Algorithmic Language Scheme
@direntry
* Guile Config: (guile-config).      Declarative program configuration
@end direntry

@titlepage
@title The Complete Guile Config Manual
@subtitle Learning to Use Guile Config in 60 Days
@author Alex Sassmannshausen

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@value{UPDATED} @*

@insertcopying
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Guile Config

This document describes Guile Config version @value{VERSION}.

@menu
* Introduction::                The need for Guile Config.
* Overview::                    The low-down on usage.
* Detailed API Reference::      The deep dive.
* On Inheritance::              Inheritance fully explained.

* Contributing::                Contributing to the Guile Config project.
* Acknowledgments::             Thanks!
* GNU Free Documentation License::  The license of this manual.
* Function Index::              Functions.
@end menu

@c *********************************************************************
@node Introduction
@chapter Introduction

Guile Config removes the headache from managing complicated command-line
applications.  And it is lovely to work with.  Think of it as a kind of
mutated version of getopt-long.

Throughout this document I will refer to command-line arguments to the
application as options.

But of course there are different kind of options you may wish to use in
your app: You've got your switches, your settings and sometimes, you've
got your secrets.  We handle them all.

@itemize
@item
You can declare:
@itemize
@item
Application internal configuration variables (secrets).
@item
Command-line configuration options (switches).
@item
Configuration file & command-line configuration options (settings).
@item
Positional command-line parameters (arguments).
@item
Sub-commands with their own set of secrets, switches, settings and
arguments & inheritance from parent specifications.
@item
Whether to automatically generate the standard @option{--help},
@option{--usage} and @option{--version} command-line options (the
library will do so by default).
@item
Authors, licenses, copyright years, synopses & descriptions.
@item
Where to install configuration files, with syntactic sugar for common
cases such as in home directory and in invocation directory
configuration files.
@item
Support for different configuration file parsing backends (only a sexp
and identity parser are currently provided)
@end itemize

@item
You can parse through:
@itemize
@item
@code{getopt-config} or @code{getopt-config-auto}, which parse
command-line arguments and return objects that can be used in the same
manner as the object returned by @code{getopt-long}.
@item
If you use the @emph{-auto} version, your program will automatically
emit help or version messages unless suppressed and exit with code 0, if
a @option{--help}, @option{--usage} or @option{--version} command-line
argument was detected.
@end itemize
@item
You can access the values of individual configuration options using the
@code{option-ref} function in the same manner that you would when using
@code{getopt-long}.
@end itemize

Guile Config builds upon the excellent @code{(ice-9 getopt-long)}
module, augmenting it with configuration file management, and recursive
sub-command management.

@c *********************************************************************
@node Overview
@chapter Overview

This chapter will provide you with concrete examples of the use of the
config library.

@menu
* Declaration::                     How to declare a configuration
* Using the darn thing::            How to use a declared configuration
@end menu

@c *********************************************************************
@node Declaration
@section Declaration

The work pony of this library is the @code{configuration}
@pxref{Configuration} command, through which you can declare your
application's options. Here follow 2 examples, the first bare-bones, the
second more elaborate.

Behind the scenes we request automatic help, usage and version
messages. Our version message will be bare-bones as we have not
specified copyright, version, license or author.

@lisp
@include examples/simple.scm
@end lisp

In this second example we will declare a configuration with 2
sub-commands.  As above, we request automatically generated help, usage
and version messages.  We also declare the author, copyright and the
license of the application for greater accuracy in the emitted
@option{--version} message.

We tell one of the sub-commands to inherit the keywords from the root
configuration using the @code{wanted} field of the @code{configuration}
record type.

@lisp
@include examples/frobnigator.scm
@end lisp

@c *********************************************************************
@node Using the darn thing
@section Using the darn thing

Usage is incredibly simple.  In most cases, you will simply want to
use @code{getopt-config-auto}, which will return a @code{codex} that you
can query with @code{option-ref}.

Using @code{getopt-config-auto} not only resolves the command-line flags
and configuration files for your application. It also scans command-line
arguments automatically for help usage & version flags and, unless our
configuration was told not too, emits messages for them.

Let us look at a fully fledged small program to show you how we might
use the entire (guile config) user API.:

@lisp
@include examples/hello-world.scm
@end lisp

Alternatively, you can give up some convenience for more control.  Using
@code{getopt-config} means you won't automatically parse the
command-line arguments for version or help flags.  We will have to do so
manually, and invoke the appropriate message generators:

@lisp
;; We assume we are operating on a file that defines a configuration
;; named config.

(let ((options (getopt-config (command-line) config)))
  (cond ((or (option-ref options 'usage #f)
             (option-ref options 'help #f))
         (emit-help options)
         (exit 0))
        ((option-ref options 'version #f)
         (emit-version options)
         (exit 0))
        (else 'do-stuff)))
@end lisp

This latter usage is closer to the @code{getopt-long} style, but can
still benefit from our emitters.  Of course you are free to write your
own version or usage emitters.

@c *********************************************************************
@node Detailed API Reference
@chapter Detailed API Reference

This chapter provides you with an in-depth reference to all user-visible
commands exposed by the config library.

@menu
* Configuration::               The configuration.
* Secrets::                     Internal configuration options.
* Switches::                    Commandline options.
* Settings::                    Configuration file options.
* Arguments::                   Positional or free parameters.
* Initializers::                Parsing command-line and config-file input.
* Accessing Options::           Accessing options in your program.
* Utilities::                   Icing on the cake.
@end menu

@c *********************************************************************
@node Configuration
@section Configuration

The configuration data type is at the core of the Config library.  Every
application using it will have at least one configuration defined.  This
root configuration in turn can contain further sub-configurations and
options (see below). Sub-configurations, define subcommands that can be
invoked by the end-user.

@deftp {Data Type} configuration

@code{configuration} allows you to create a new configuration or
sub-configuration.  You should use this form when declaring your
program's configurations.

@code{configuration}'s @code{generate-help?}, @code{generate-usage?} &
@code{generate-version?} default to #t.  @code{directory} is optional
unless you have @code{setting}s in your @code{keywords} list.  The
@code{parser} defaults to @code{identity-parser}, which does not
generate configuration files.

Finally, @code{license}, @code{copyright} and @code{author} can be
omitted, but doing so will result in a very limited @emph{version}
string.

@table @asis
@item @code{name}
A symbol specifying the application/sub-command name.

@item @code{synopsis}
A string of less than 40 characters providing a brief explanation of
this configuration.

@item @code{long}
A string providing a detailed explanation of this configuration.

@item @code{wanted}
An association list, which defaults to '(), specifying what keywords and
arguments should be inherited @pxref{On Inheritance} from the parent
configuration.  The keys of the association list can only be
@code{keywords} or @code{arguments}.

@example
`((keywords . (length author))
  (arguments . (input-file)))
@end example

@item @code{keywords}
A list containing @code{secret}s, @code{switch}es and/or
@code{setting}s.

@item @code{arguments}
A list containing @code{argument}s. Arguments define positional
parameters for your program.

@item @code{subcommands}
A list containing further @code{configuration}s.  These configurations
are considered @emph{sub-configurations} of this
@emph{parent-configuration}.  If there is no
@emph{parent-configuration}, the current configuration is also referred
to as the @emph{root-configuration}.

@emph{sub-configurations} define subcommands that can be invoked by the
end-user when running your application.

@item @code{directory}
Either a single @code{path}, or a list of @code{path}s, depending on
whether your application has a single location defining configuration
files or multiple locations, where one takes precedence over the other.

The ordering of the list defines which locations take precedence over
others, with those towards the end overriding those at the beginning.

@item @code{version}
A simple string defining the version of this application.  This is used
when generating the @emph{--version} string.

@item @code{license}
A @code{license} record.  We have many pre-defined licenses that we
copypasta'd from the @emph{Guix} project, so any licenses defined there
should work here.

@item @code{copyright}
A list of years for which the author of this program or sub-command
claims copyright.

@item @code{author}
A string containing the name of the author of this program or
sub-command.

@item @code{parser}
A @code{parser} record, which in turn provides a means to parse and
write this configuration's configuration file.

This defaults to the @emph{identity-parser}, which does not actually
generate configuration files, and thus ignores the @code{directory}
field.

Currently the only alternative parser that comes out of the box is the
@emph{sexp-parser}, which generates s-expression based configuration
files.

@item @code{alias}
A symbol providing an alternative name for this configuration.  This can
be useful for sub-commands, in order to provide shorter, alternative
means of invocation.

@item @code{generate-help?}
A boolean value indicating whether we should automatically provide the
@emph{--help} switch.

This defaults to #t.

@item @code{generate-usage?}
A boolean value indicating whether we should automatically provide the
@emph{--usage} switch.

This defaults to #t.

@item @code{generate-version?}
A boolean value indicating whether we should automatically provide the
@emph{--version} switch.

This defaults to #t.

@item @code{generate-version?}
A boolean value indicating whether we should automatically provide the
@emph{--cmdtree} switch.  This switch emits an outline of the
subcommands available in your application.

This defaults to #f.
@end table
@end deftp

@c *********************************************************************
@node Secrets
@section Secrets

Private options are configuration values that cannot be manipulated by
the end user, either through command-line arguments or through
configuration files.  Internally, private-options are used in order to
implement the version, license, author and copyright configuration
values.  Private options could be used to store any other internal
program configuration values, such as data directories etc.

@deffn {Scheme Procedure} private-option name terse [#:long #f] @
       [#:value '<unset>] [#:test boolean?] [#:inherit #t]

@code{private-option} is a convenience procedure to create private
options.  Private options should normally always have a value, and the
combination of '<unset> as value and boolean? as test will cause an
error.

@table @code
@item name
A symbol specifying the name of the private option.

@item terse
A string of less than 40 characters providing a brief explanation of
this private option.

@item long
A string providing a detailed explanation of this private option.

@item value
The value of this private option.  This can be an arbitrary values, but
it should pass the predicate defined with @code{test}.  Value is
normally either set by the programmer, or by this programs build system
at installation time.

@item test
A predicate to evaluate @code{value}.  We will throw an error if
@code{value} does not satisfy this predicate.

@item inherit
A boolean indicating whether this option should be passed down to the
containing configuration's subcommand configurations.  By default this
is set to #t, which means that if the containing configuration's inherit
setting is set to #t, this option will be passed down.
@end table
@end deffn

Normally private options are not named; instead they are simply defined
immediately within the configuration in which it is needed.

@c *********************************************************************
@node Switches
@section Switches

@code{Public options} are configuration parameters that can be set by
the end-user using command-line parameters to this program or
sub-command.  Using the @code{help?}, @code{usage?} or @code{version?}
keywords during configuration definition will result in the automatic
addition of the 'help, 'usage and 'version public options to the
configuration (using @code{version?} will also result in the automatic
addition of the 'version-number private-option).

@deffn {Scheme Procedure} public-option name terse [#:long #f] @
       [#:value '<unset>] [#:single-char #f] [#:test boolean?] @
       [#:handler identity] [#:example ``VALUE''] [#:optional? #f] @
       [#:inherit #t]

@code{public-option} is a convenience procedure to create public
options.  They are normally defined anonymously as part of
configurations, but can be named if the same public option is to be used
in multiple configurations.

@table @code
@item name
A symbol specifying the name of the public option.

@item terse
A string of less than 40 characters providing a brief explanation of
this public option.

@item long
A string providing a detailed explanation of this public option.

@item value
The value of this public option.  This can be an arbitrary values, but
it should pass the predicate defined with @code{test}.  Value is
normally set by the programmer, but can be left '<unset> to generate a
mandatory command-line parameter.  Alternatively, if value is set to #t
or #f, and test is left as a boolean?, then we will generate a
command-line parameter that acts as a flag, i.e. which does not take a
value.

@item single-char
If specified this should be a character type value, specifying the short
name for this command-line parameter.

@item test
A predicate with which we test the value supplied by default in
@code{value} or by the end-user on the command-line.  If this public
option is not a @emph{flag}, then @code{test} should either be
@code{string?}, or you should specify @code{handler} to transform the
value specified by the end user on the command-line into the value that
will pass test.

For instance, if we expect the end user to provide a number as input to
this public option, then we can set @code{test} to @code{number?} and
@code{handler} to @code{string->number}.

@item handler
A procedure of one argument that will be applied to the value supplied
by the end-user on the command-line to transform that value (which will
always be a string) into a different type that can pass @code{test}.

This interplay between @code{test} and @code{handler} allows us to
perform input validation entirely at the configuration parsing stage,
thus freeing the programmer from having to do this in the body of the
program itself.

@item example
An string providing an example value which will be displayed to the
end-user when they request @code{--help}, or @code{--usage}.

@item optional?
If set to #t, this command-line parameter can be used as a flag, or
alternatively, it can be passed a value by the end-user.  Setting this
to #t will require you to provide an appropriate @code{handler}, taking
either a boolean or a string as input.  You may also have to provide a
@code{test} predicate that expects inputs of potentially different
types.

@item inherit
A boolean indicating whether this option should be passed down to the
containing configuration's subcommand configurations.  By default this
is set to #t, which means that if the containing configuration's inherit
setting is set to #t, this option will be passed down.
@end table
@end deffn

@c *********************************************************************
@node Settings
@section Settings

Open options are configuration parameters that can be set by the
end-user using command-line parameters or using a configuration file.
Attaching any open options to a configuration will require that you also
specify a @code{config-dir} for that configuration, otherwise an error
will be thrown.

Open options will cause the program to generate configuration files if
they do not yet exist, and set the values in those according to the
default values of all open options defined within the configuration.
The program will then parse the configuration files, and initialize all
open options to the values found in the configuration files.  Finally
the program will parse its command-line parameters and override any
values initialized by the configuration files with the new values
derived from the command-line.

@deffn {Scheme Procedure} open-option name terse [#:long #f] @
       [#:value '<unset>] [#:single-char #f] [#:test boolean?] @
       [#:handler identity] [#:example ``VALUE''] [#:optional? #f] @
       [#:inherit #t]

@code{open-option} is a convenience procedure to create open options.
They are normally defined anonymously as part of configurations, but can
be named if the same open option is to be used in multiple
configurations.

@table @code
@item name
A symbol specifying the name of the open option.

@item terse
A string of less than 40 characters providing a brief explanation of
this open option.

@item long
A string providing a detailed explanation of this open option.

@item value
The value of this open option.  This can be an arbitrary values, but it
should pass the predicate defined with @code{test}.  Value should not be
left as '<unset>.  Doing so is currently unspecified.  If value is set
to #t or #f, and test is left as a boolean?, then we will generate a
command-line parameter that acts as a flag, i.e. which does not take a
value.

@item single-char
If specified this should be a character type value, specifying the short
name for this command-line parameter.

@item test
A predicate with which we test the value supplied by default in
@code{value}, in the configuration file or by the end-user on the
command-line.  If this open option is not a @emph{flag}, then
@code{test} should either be @code{string?}, or you should specify
@code{handler} to transform the value specified by the end user on the
command-line into the value that will pass test.

For instance, if we expect the end user to provide a number as input to
this public option, then we can set @code{test} to @code{number?} and
@code{handler} to @code{string->number}.

For values provided in the configuration file, we simply apply the
predicate directly to the value, meaning that configuration files must
provide Scheme values.

@item handler
A procedure of one argument that will be applied to the value supplied
by the end-user on the command-line to transform that value (which will
always be a string) into a different type that can pass @code{test}.

This interplay between @code{test} and @code{handler} allows us to
perform input validation entirely at the configuration parsing stage,
thus freeing the programmer from having to do this in the body of the
program itself.

Handlers are only used when parsing command-line input, not when parsing
values specified in the configuration files.

@item example
An string providing an example value which will be displayed to the
end-user when they request @code{--help}, or @code{--usage}.

@item optional?
If set to #t, this command-line parameter can be used as a flag, or
alternatively, it can be passed a value by the end-user.  Setting this
to #t will require you to provide an appropriate @code{handler}, taking
either a boolean or a string as input.  You may also have to provide a
@code{test} predicate that expects inputs of potentially different
types.

@item inherit
A boolean indicating whether this option should be passed down to the
containing configuration's subcommand configurations.  By default this
is set to #t, which means that if the containing configuration's inherit
setting is set to #t, this option will be passed down.
@end table
@end deffn

@c *********************************************************************
@node Arguments
@section Arguments

Free parameters are configuration values that slot into the
@code{free-params} field of the @code{configuration} procedure.  They
are additional ``options'' that allow you to declare what kind of
positional arguments your application accepts.

As we are talking positional arguments here, the ordering in the list of
@code{free-params} is important.  Please also bear in mind that, for the
same reason, you cannot have mandatory positional arguments after your
first optional positional argument.

Finally, inheritance is not implemented for Free Parameters.

@deffn {Scheme Procedure} free-param name terse [#:long #f] @
       [#:value '<unset>] [#:test boolean?] [#:handler identity] @
       [#:example ``Value''] [#:optional #f]

@code{free-param} is a convenience procedure to create free or
positional arguments.  Free parameters normally are mandatory, and do
not need to be given a default value, though it may be useful to do so
if you declare one optional.

@table @code
@item name
A symbol specifying the name of the free parameter.

@item terse
A string of less than 40 characters providing a brief explanation of
this free parameter.

@item long
A string providing a detailed explanation of this free parameter.

@item value
The value of this free parameter.  This can be an arbitrary value, but
it should pass the predicate defined with @code{test}.  Value is
normally either set by the programmer, or by this programs build system
at installation time.

@item test
A predicate to evaluate @code{value}.  We will throw an error if
@code{value} does not satisfy this predicate.

@item handler
A procedure of one argument that will be applied to the value supplied
by the end-user on the command-line to transform that value (which will
always be a string) into a different type that can pass @code{test}.

This interplay between @code{test} and @code{handler} allows us to
perform input validation entirely at the configuration parsing stage,
thus freeing the programmer from having to do this in the body of the
program itself.

@item example
A string providing an example value which will be displayed to the
end-user when they request @code{--help}, or @code{--usage}.  If
@code{example} is not provided, we will use the name of the free
parameter instead.

@item optional?
If set to #t, this free paramater can be omitted by the end user.  In
this case we will either use the default value, or return #f when it is
queried.
@end table
@end deffn

@c *********************************************************************
@node Initializers
@section Initializers

After declaring your configurations you will still need to initialize
your program.  This is done by passing the command-line parameters the
script was invoked with, and your declared configuration to an
initializer.

@deffn {Scheme Procedure} getopt-config @var{args} @var{config}
@deffnx {Scheme Procedure} getopt-config-auto @var{args} @var{config}

The above procedures work very similarly.  Both have taken their
inspiration from @code{getopt-long}'s way of doing things: @var{args}
should be the command-line arguments passed to the script and
@var{config} should be the declared configuration.

The second procedure will automatically check whether the end-user
requested @emph{--help}, @emph{--usage}, or @emph{--version} and will
emit an appropriate message and exit the program if so.
@end deffn

@c *********************************************************************
@node Accessing Options
@section Accessing Options

At its heart, (guile config) aims to easily replace (ice-9
getopt-long).  Because of this the library exports @code{option-ref},
which behaves almost identically to (ice-9 getopt-long)'s
@code{option-ref}.

@deffn {Scheme Procedure} option-ref @var{codex} @var{key} [@var{default}]
Try to find the value for @var{key} in @var{codex}, returning
@var{default} if the value is unset or cannot be found.

@var{key} should be:
@itemize
@item
a symbol if you want to retrieve a keyword from @var{codex};
@item
a list of exactly one symbol, if you want to retrieve an argument from
@var{codex};
@item
or the empty list if you want to retrieve all arguments from
@var{codex}.
@end itemize
@end deffn

@c *********************************************************************
@node Utilities
@section Utilities

@deffn {Scheme Procedure} emit-help @var{codex} [@var{port}]
@end deffn

@deffn {Scheme Procedure} emit-version @var{codex} [@var{port}]
@end deffn

@deffn {Scheme Procedure} options-write @var{codex} [@var{configuration} @var{eager-only?}]
@end deffn

@c *********************************************************************
@node On Inheritance
@chapter On Inheritance

Inheritance can mean many things.  In our context, inheritance can be
thought of as a means to achieve two things:

@itemize
@item
Economy - there is no need to repeat common option declarations.
@item
Consistency - we can ensure we expose the same options for the same
functionality, without having to manually ensure consistency.
@end itemize

There are 2 uses of inheritance in this library.

Within the (guile config) API, inheritance is implemented at the
@code{configuration} level, through the @code{wanted} field.  This field
can be set in any sub-configuration to indicate which precise keywords
or arguments should be inherited from its parent.  In this way options
can be passed down through the configuration graph as far as required.

There are some limitations to this approach, namely:
@itemize
@item
It is not possible to automate inheritance.
@item
Every inherited option must be explicitly specified.
@end itemize

In addition to inheritance through the @code{wanted} field, we also have
automatic inheritance in the following @code{configuration} fields:
@itemize
@item
directory
@item
version
@item
license
@item
copyright
@item
author
@item
parser
@item
generate-help?
@item
generate-usage?
@item
generate-version?
@end itemize

This means that you only have to set these fields once, in the
@emph{root-configuration}.  After this, if you want to change a field in
one of the children, you can just set that field in the child
configuration.

@c *********************************************************************
@node Contributing
@chapter Contributing

Guile Config is an open project and I actively invite contribution.  Get
in touch with the project on @email{alex@@pompo.co}.  The project
welcomes ideas, bug reports, patches, or feedback.

Please see the HACKING file that comes with the Guile Config source code
for practical details about contributions.

@c *********************************************************************
@node Acknowledgments
@chapter Acknowledgments

Guile Config is intended as a gift to the Guile & Guix communities,
without whom I would never have learned to program.

@c *********************************************************************
@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@c *********************************************************************
@node Function Index
@unnumbered Function Index
@printindex fn

@bye

@c Local Variables:
@c ispell-local-dictionary: "american";
@c End:
